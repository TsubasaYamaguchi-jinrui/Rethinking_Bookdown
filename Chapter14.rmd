# Adventures in Covariance  
## Varying slopes by construction  
ランダム切片とランダム傾きの両方を推定するためには、多変量正規分布を用いる必要がある。  

### Simulate and population  
ロボットがカフェを訪れた際の待ち時間に関するデータをシミュレートする。パラメータは以下のとおりとする。すなわち、ランダム切片とランダム傾きは平均と標準偏差がそれぞれ3.5と-1, 1と0.7の多変量正規分布から得られるとする。なお、分散共分散行列は通常以下のようにあらわす。なお、$\sigma_{\alpha}$と$\sigma_{\beta}$はそれぞれランダム切片とランダム傾きのばらつき（標準偏差）を表し、$\rho$はそれらの相関を表す。  

$$
\sum =
\begin{bmatrix}
  \sigma_{\alpha}^2 & \sigma_{\alpha}\sigma_{\beta}\rho\\
  \sigma_{\alpha}\sigma_{\beta}\rho & \sigma_{\beta}
\end{bmatrix}
$$

```{r}
a <- 3.5         # averange morning wait time  
b <- (-1)          # average difference afternoon wait time  
sigma_a <- 1     # std dev in intercepts   
sigma_b <- 0.5   # std dev in slopes  
rho <- (-0.7)     # correlation between interecpts and slopes

mu <- c(a,b) 
cov_ab <- sigma_a*sigma_b*rho #共分散
sigma <- matrix(c(sigma_a^2, cov_ab, 
                  cov_ab, sigma_b^2), ncol=2)　# 分散共分散行列
```

なお、分散共分散行列は以下のようにしても作成できる。  
```{r}
sigmas <- c(sigma_a, sigma_b)
rho <- matrix(c(1, rho,
              rho, 1), nrow =2)

sigma <- diag(sigmas) %*% rho %*% diag(sigmas) 
```

それでは、それぞれのお店（N=20）の切片と傾きをシミュレートする。  
```{r}
n_cafes <- 20

set.seed(5)

vary_effects <- 
  MASS::mvrnorm(n_cafes, mu, sigma) %>% 
  data.frame() %>% 
  set_names("a_cafe", "b_cafe")

head(vary_effects)
```

```{r, echo = FALSE}
sim <- crossing(a_cafe = seq(1,6.5,length.out=100),
                 b_cafe = seq(-2.5,0.5, length.out=100)) %>% 
        mutate(x = crossing(a_cafe, b_cafe)) %>% 
        mutate(dens = dmvnorm(x, mean = mu, sigma))
        

vary_effects %>% 
  ggplot(aes(x=a_cafe, y = b_cafe))+
  geom_contour(data = sim, aes(x=a_cafe,y=b_cafe,z=dens),
               color = "gray")+
  geom_point()+
  xlab("intercepts(a_cafe)")+
  ylab("slopes(b_cafe)")+
  theme(aspect.ratio=1)
```

### Simulate observation  
それでは、それぞれのお店を10回訪れたときのデータをシミュレートする。
```{r}
n_visits <- 10
sigma_y <- 0.5

set.seed(22)

d <- 
  vary_effects %>% 
  mutate(cafe = 1:n()) %>% 
  tidyr::expand(nesting(cafe, a_cafe, b_cafe),
         visits = 1:n_visits) %>% 
  mutate(afternoon = rep(0:1, times = n()/2)) %>% 
  mutate(mu = a_cafe + b_cafe*afternoon) %>% 
  mutate(wait = rnorm(n=n(), mean=mu, sd=sigma_y))

d %>% 
  slice_sample(n=10)
```

実際のデータをカフェ2とカフェ8について描写してみる。  
```{r, echo = FALSE}
library(lemon)

d %>% 
  filter(cafe %in% c(2,8)) %>% 
  mutate(afternoon = ifelse(afternoon == 0,"M","A")) %>% 
  mutate(day = ceiling(visits/2)) %>% 
  mutate(cafe = str_c("cafe ", cafe)) %>% 
  ggplot(aes(x = visits, y = wait, group=day))+
  geom_point()+
  geom_line()+
  scale_x_continuous(breaks = 1:10, labels =rep(c("M","A"),times=5))+
  facet_rep_wrap(~cafe, nrow=2,
                 repeat.tick.labels = TRUE)+
  ylab("wait time in minutes")+
  theme(strip.background = element_blank(),
        aspect.ratio=0.5)

```

### The varying slope model  
それでは、モデリングを行う。モデル式は以下の通り。  

$$
\begin{aligned}
  W_{i} &\sim Normal(\mu_{i}, \sigma)\\
  \mu_{i} &= \alpha_{cafe[i]} + \beta_{cafe[i]}A_{i}\\
  \begin{bmatrix}
    \alpha_{cafe} \\ \beta_{cafe}
  \end{bmatrix}
    &\sim MVNormal(
  \begin{bmatrix} 
     \alpha \\ \beta 
  \end{bmatrix}, \mathbf{S})\\
  \mathbf{S} &= 
       \begin{bmatrix}
          \sigma_{\alpha} & 0 \\
          0 & \sigma_{\beta}
        \end{bmatrix}
        \mathbf{R}
        \begin{bmatrix}
          \sigma_{\alpha} & 0 \\
          0 & \sigma_{\beta}
        \end{bmatrix}\\
  \mathbf{R} &= \begin{bmatrix}
          1 & \rho \\
          \rho & 1
        \end{bmatrix}\\
  \alpha &\sim Normal(5,2)\\
  \beta &\sim Normal(-1,0.5)\\
  \sigma &\sim Exponential(1)\\
  \sigma_{\alpha} &\sim Exponential(1)\\
  \sigma_{\beta} &\sim Exponential(1)\\
  mathbf{R} &\sim LKJcorr(2)\\
\end{aligned}
$$

<br />  

なお、$LKJcorr$分布は以下のようなパラメータ$\eta$を持つ分布である。$\eta=1$のときは一様分布で、$\eta$が大きくなるほど分布が狭くなっていく。    
```{r, echo = FALSE}
set.seed(14)

r_1 <- rlkjcorr(1e4, K=2, eta=1) %>% 
  data.frame()

r_2 <- rlkjcorr(1e4, K=2, eta=2) %>% 
  data.frame()

r_4 <- rlkjcorr(1e4, K=2, eta=4) %>% 
  data.frame()

text <- 
  tibble(x     = c(.83, .625, .45),
         y     = c(.56, .75, 1.07),
         label = c("eta = 1", "eta = 2", "eta = 4"))

r_1 %>% 
  ggplot(aes(x = X2))+
  geom_density(color = "transparent",
         fill = "orange1", alpha = 1/4)+
  geom_density(data = r_2,
               color = "transparent",
         fill = "orange2", alpha = 1/6)+
  geom_density(data = r_4,
               color = "transparent",
         fill = "orange3", alpha = 1/8)+
  geom_text(data = text,
            aes(x = x, y = y, label = label))+
  scale_y_continuous(NULL, breaks = NULL) +
  labs(title = expression(LKJcorr(eta)),
       x = "correlation")+
  theme(aspect.ratio=0.8)

```
<br />  

それでは、モデリングを行う。  
```{r}
b14.1 <- 
  brm(data =d,
      family = gaussian,
      wait ~ 1 + afternoon + (1+afternoon|cafe),
      prior = c(prior(normal(5,2), class = Intercept),
                prior(normal(-1,0.5), class = b),
                prior(exponential(1), class = sigma),
                prior(exponential(1), class =sd),
                prior(lkj(2), class = cor)),
      backend = "cmdstanr",
      seed = 155, file = "output/Chapter14/b14.1")
```

切片と傾きの相関の事前分布と事後分布は以下の通り。  
```{r, echo = FALSE}
post <- posterior_samples(b14.1)
post %>% 
  ggplot()+
  geom_density(aes(x = cor_cafe__Intercept__afternoon),
               color = "navy", linetype=1)+
  geom_density(data = r_2, aes(x=X2),
               color = "orange1",
               linetype =2)+
  annotate(geom = "text", 
           x = c(-0.1, 0.5), y = c(1.5, 0.85), 
           label = c("posterior", "prior"),
           color = c("navy", "orange1"))+
  scale_y_continuous(NULL, breaks = NULL) +
  labs(subtitle = "Correlation between intercepts\nand slopes, prior and posterior",
  x = "correlation")+
  theme(aspect.ratio=1)
```

各カフェの切片と傾きの推定値と元データを比較したものが以下の図である。モデルによる推定値では全体の平均へと縮合が起きていることが分かる。
```{r, echo = FALSE}
coef <- coef(b14.1)

raw <- d %>% 
  group_by(afternoon, cafe) %>% 
  summarise(mean = mean(wait)) %>% 
  ungroup() %>% 
  pivot_wider(names_from = afternoon,
              values_from = mean) %>% 
  set_names("cafe","int_raw", "slope_raw") %>% 
  mutate(slope_raw = slope_raw -int_raw)

coef$cafe[,1,] %>% 
  data.frame() %>% 
  bind_cols(raw) %>%
  set_names("int_est", "slope_est", "cafe",
            "int_raw", "slope_raw") %>%
  pivot_longer(c(1,4), names_to = "type",
               values_to = "intercept") %>% 
  pivot_longer(c(1,3), 
               names_to = "type2",
               values_to = "slope") %>% 
  filter(type=="int_est"&type2=="slope_est"|
           type == "int_raw"&type2 == "slope_raw") %>% 
  mutate(type = rep(c("est","true"), times =20)) %>%
  ggplot()+
  geom_point(aes(x = intercept, y = slope,
                 color = type, shape = type),
             size=2)+
  scale_color_manual(values = c("navy", "black"))+
  scale_shape_manual(values = c(19,1))+
  geom_line(aes(x = intercept, y = slope,group=cafe))+
  geom_contour(data = sim, aes(x=a_cafe,y=b_cafe,z=dens),
               color = "gray")+
  theme(aspect.ratio=1,
        legend.position = "none") -> p1
```

続いて、午前と午後の待ち時間の元データとモデルによる推定値は以下の通り。同様に縮合が生じていることが分かる。  
```{r, echo = FALSE}
nd <- distinct(d, cafe, afternoon)

fitb14.1 <- fitted(b14.1, newdata = nd) %>% 
            data.frame() %>% 
            bind_cols(nd) %>% 
            dplyr::select(cafe, afternoon, Estimate)

raw_dat <- d %>% 
           group_by(cafe, afternoon) %>% 
           summarise(mean = mean(wait))

v <- MASS::mvrnorm(1e5, mu, sigma) %>% 
     data.frame() %>% 
     mutate(X2 = X1 + X2)

mu2 <- c(mean(v$X1), mean(v$X2))
sigma2 <- cov(v)

sim2 <- crossing(morning = seq(0,6,length.out=100),
                 afternoon = seq(0,5, length.out=100)) %>% 
        mutate(x = crossing(morning,afternoon)) %>% 
        mutate(dens = dmvnorm(x, mu2, sigma2))
        

full_join(fitb14.1, raw_dat, by = c("cafe", "afternoon")) %>% 
  set_names("cafe", "afternoon", "est", "raw") %>% 
  mutate(afternoon= ifelse(afternoon==0,"morning","afternoon")) %>% 
  pivot_longer(est:raw,
               names_to = "type",
               values_to = "wait") %>% 
  pivot_wider(names_from = afternoon,
              values_from = wait) %>% 
  ggplot()+
  geom_point(aes(x=morning, y=afternoon, color = type,
                 shape = type),
             size=2)+
  scale_color_manual(values = c("navy", "black"))+
  scale_shape_manual(values = c(19,1))+
  geom_line(aes(x = morning, y = afternoon,group=cafe))+
  geom_contour(data = sim2, aes(x=morning,y=afternoon,z=dens),
               color = "gray")+
  geom_abline(slope=1,intercept=0, linetype = "dashed")+
  theme(aspect.ratio=1) -> p2

p1+p2
```

## Advanced varing slopes  
チンパンジーの実験データ[@Silk2005]を用いて、2つ以上ランダム傾きを用いるモデルを考える。

```{r}
data(chimpanzees)
d2 <- chimpanzees

d2 <- 
  d2 %>% 
  mutate(actor = factor(actor),
         block = factor(block),
         treatment = factor(1+prosoc_left + 2*condition),
         labels = factor(treatment, levels =1:4,
                         labels = c("r/n","l/n","r/p","l/p")))
```

モデル式は以下のようになる。以下のモデルでは、各個体、各ブロックによって条件（treatment）の効果が変わることを想定している。  

$$
\begin{aligned}
  L_{i} &\sim Binomial(1,p_{i})\\
  logit(p_{i}) &= \gamma_{TID[i]} + \alpha_{ACTOR[i],TID[i]}+
  \beta_{BLOCK[i],TID[i]}\\
  \gamma_{j} &\sim Normal(0,1)\\
  \begin{bmatrix}
  \alpha_{j,1}\\ \alpha_{j,2}\\ \alpha_{j,3}\\ \alpha_{j,4}
  \end{bmatrix}
  & \sim MVNormal(
  \begin{bmatrix}
  0\\0\\0\\0
  \end{bmatrix}
  , \sum_{ACTOR})\\
  \begin{bmatrix}
  \beta_{j,1}\\ \beta_{j,2}\\ \beta_{j,3}\\ \beta_{j,4}
  \end{bmatrix}
  & \sim MVNormal(
  \begin{bmatrix}
  0\\0\\0\\0
  \end{bmatrix}
  , \sum_{BLOCK})\\
  \sum_{ACTOR} &= \mathbf{S}_{\alpha}\mathbf{R}_{\alpha}\mathbf{S}_{\alpha}\\
  \sum_{BLOCK} &= \mathbf{S}_{\beta}\mathbf{R}_{\beta}\mathbf{S}_{\beta}\\
  \mathbf{S}_{\alpha} &= 
  \begin{bmatrix}
     \sigma_{\alpha,[1]}&0&0&0\\
     0&\sigma_{\alpha,[2]}&0&0\\
     0&0&\sigma_{\alpha,[3]}&0\\
     0&0&0&\sigma_{\alpha,[4]}
  \end{bmatrix}\\
  \mathbf{S}_{\beta} &= 
  \begin{bmatrix}
     \sigma_{\beta,[1]}&0&0&0\\
     0&\sigma_{\beta,[2]}&0&0\\
     0&0&\sigma_{\beta,[3]}&0\\
     0&0&0&\sigma_{\beta,[4]}
  \end{bmatrix}\\
 \mathbf{R}_{\alpha} &=
    \begin{bmatrix}
     1&\rho_{\alpha,[1,2]} & \rho_{\alpha,[1,3]} & \rho_{\alpha,[1,4]}\\
     \rho_{\alpha,[2,1]} & 1 &\rho_{\alpha,[2,3]} & \rho_{\alpha,[2,4]}\\
      \rho_{\alpha,[3,1]} & \rho_{\alpha,[3,2]} & 1 & \rho_{\alpha,[3,4]}\\
      \rho_{\alpha,[4,1]} & \rho_{\alpha,[4,2]} & \rho_{\alpha,[4,3]} & 1\\
  \end{bmatrix}\\
  \mathbf{R}_{\beta} &=
    \begin{bmatrix}
     1&\rho_{\beta,[1,2]} & \rho_{\beta,[1,3]} & \rho_{\beta,[1,4]}\\
     \rho_{\beta,[2,1]} & 1 &\rho_{\beta,[2,3]} & \rho_{\beta,[2,4]}\\
      \rho_{\beta,[3,1]} & \rho_{\beta,[3,2]} & 1 & \rho_{\beta,[3,4]}\\
      \rho_{\beta,[4,1]} & \rho_{\beta,[4,2]} & \rho_{\beta,[4,3]} & 1\\
  \end{bmatrix}\\
  \sigma_{\alpha,[1]},...\sigma_{\alpha,[4]} &\sim Exponential(1)\\
  \sigma_{\beta,[1]},...\sigma_{\beta,[4]} &\sim Exponential(1)\\
  \mathbf{R}_{\alpha} &\sim LKJ(2)\\
  \mathbf{R}_{\beta} &\sim LKJ(2)
\end{aligned}
$$
<br/>  

それでは、`brms`でモデルを回す。  
```{r}
b14.3 <- 
  brm(data =d2,
      family = bernoulli,
      pulled_left ~ 0 + treatment + (0+treatment|actor) + 
        (0+treatment|block),
      prior = c(prior(normal(0,1), class = b),
                prior(exponential(1), class = sd),
                prior(lkj(2), class = cor)),
      backend = "cmdstanr",
      seed = 123, file = "output/Chapter14/b14.3")
```

ランダム切片の標準偏差は以下の通り（表\@ref(tab:res-b14-3)）。
```{r res-b14-3}
posterior_summary(b14.3) %>% 
  data.frame() %>% 
  rownames_to_column(var = "par") %>% 
  filter(str_detect(par,"sd")) %>% 
  kable(digits = 2,
        booktabs = TRUE,
        caption = "b14.3の結果。") %>% 
  kable_styling(latex_options = c("striped", "hold_position"))
```

結果を図示すると以下の通り。青い点は実データを表す。以前のモデルよりも、個体ごとのばらつきをうまく表現することができている。また、縮合が生じていることも分かる（特にactor2）。また、標準偏差が小さかった条件（treatment1と2）でより縮合が生じていることも分かる。
```{r, echo = FALSE, out.width = "100%"}
nd <- distinct(d2,actor,condition,labels,prosoc_left,treatment) %>% 
  mutate(block =5)

library(lemon)
     
fitted(b14.3, newdata = nd, probs = c(0.045,0.955)) %>% 
  data.frame() %>% 
  bind_cols(nd) %>% 
  mutate(treatment = factor(treatment),
         condition = factor(condition)) %>% 
  arrange(actor,treatment) %>% 
  mutate(side = rep(c("R","L"), times =14)) %>% 
  left_join(d2 %>% group_by(actor,treatment) %>% 
              mutate(prop = mean(pulled_left)) %>% 
              distinct(actor,treatment,prop),
            by = c("actor","treatment")) %>% 
  mutate(actor = str_c("actor ",actor)) %>% 
  ggplot(aes(x = labels))+
  geom_hline(aes(yintercept = mean(prop)), alpha =1/2, linetype = "dashed")+
  geom_point(aes(y=prop, shape = condition), alpha = 2/3,
             color = "navy", size=3)+
  geom_line(aes(y = Estimate,group = side), alpha = 1/2)+
  geom_pointinterval(aes(y = Estimate,
                         ymin = Q4.5, ymax = Q95.5,
                         shape = condition, fill = condition),
                     point_size =2, interval_alpha = 1/2)+
  scale_shape_manual(values = c(21,19))+
  scale_fill_manual(values = c("white","black"))+
  facet_rep_wrap(~actor, nrow =2,
                 repeat.tick.labels = TRUE)+
  theme(strip.background = element_blank(),
        legend.position = "none")

```

## Instruments and causal designs  
### Instrumental variables  
教育が賃金に与える影響を検証したいとする。しかし、単に賃金を教育の程度で回帰したとしても、その因果関係を知ることはできない。例えば、両方に対して影響を与えている共通の要因が考えられるからである（下図）。  

```{r, echo = FALSE, fig.height = 2}
library(ggdag)

dag_coords <-
  tibble(name = c("E", "U", "W"),
         x    = c(1, 2, 3),
         y    = c(1, 2, 1))

dagify(E ~ U,
       W ~ E + U,
       coords = dag_coords) %>%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_point(aes(color = name == "U"),
                 shape = 21, stroke = 2, fill = "white", size = 6, show.legend = F) +
  geom_dag_text(color = "black", family = "Century") +
  geom_dag_edges(edge_colour = "black") +
  scale_color_manual(values = c("navy", "black")) +
  theme_minimal()+
  scale_x_continuous(NULL, breaks = NULL, expand = c(0,0.2)) +
scale_y_continuous(NULL, breaks = NULL, expand = c(0,0.2)) +
  theme(aspect.ratio=1,
        panel.grid = element_blank())
```

このようなとき、以下の基準を満たす*instrumental variable*を用いることでこのような状況を克服することができることがある。  

(1) Uとは独立（$U\bot Q$）  
(2) Eと独立でない（$E\not\bot Q$）  
(3) QはEを通してのみWに影響を与える。  

そのようなQをDAGで表すと以下のようになる。例えば、この例では生まれたのがいずれの四半期にあたるのかをQとして用いることができるかもしれない[@angrist1991]。これは、早く生まれた人ほど学校教育を受けない傾向があることによる。このとき、QとEを同時に説明変数に含めるとEで条件づけるとQとUが独立ではなくなり（EはQとUの合流点であるため）、結果的にQとWも独立ではなくなる。その結果、さらにEの係数が交絡するので、Qは$\color{blue}{\text{BIAS AMPLIFIER}}$と呼べる。  
```{r, echo = FALSE, fig.height = 2}
dag_coords <-
  tibble(name = c("Q", "E", "U", "W"),
         x    = c(0, 1, 2, 3),
         y    = c(2, 1, 2, 1))

dagify(E ~ Q + U,
       W ~ E + U,
       coords = dag_coords) %>%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_point(aes(color = name == "U"),
                 shape = 21, stroke = 2, fill = "white",
                 size = 6, show.legend = F) +
  geom_dag_text(color = "black", family = "Century") +
  geom_dag_edges(edge_colour = "black") +
  scale_color_manual(values = c("navy", "black")) +
  theme_minimal()+
  scale_x_continuous(NULL, breaks = NULL, expand = c(0,0.2)) +
scale_y_continuous(NULL, breaks = NULL, expand = c(0,0.2))+
  theme(aspect.ratio=1,
        panel.grid = element_blank())
```

それでは、上のDAGに基づいてデータをシミュレートする。ここでは、教育による収入への影響はないものとする。    
```{r}
set.seed(73)
n <- 500
dat_sim <- 
  tibble(u_sim = rnorm(n,mean=0,sd=1),
         q_sim = sample(1:4, size=n, replace=TRUE)) %>% 
  mutate(e_sim = rnorm(n, mean=u_sim + q_sim, sd=1),
         w_sim = rnorm(n, mean=u_sim + 0*e_sim, sd =1)) %>% 
  mutate(w = standardize(w_sim),
         e = standardize(e_sim),
         q = standardize(q_sim))

head(dat_sim)
```

それでは、モデリングを行う。まずは、Qを含めないモデル。  
```{r}
b14.4 <- 
  brm(data = dat_sim,
      family = gaussian,
      w ~ 1 + e,
      prior = c(prior(normal(0, 0.2), class = Intercept),
                prior(normal(0, 0.5), class = b),
                prior(exponential(1), class = sigma)),
      backend = "cmdstanr",
      seed =14, file = "output/Chapter14/b14.4"
      )
```

結果は以下の通り（表\@ref(tab:res-b14-4)）。教育の影響はないにもかかわらず、交絡によって係数が正になっていることが分かる。  
```{r res-b14-4}
posterior_summary(b14.4) %>% 
  data.frame() %>% 
  rownames_to_column(var = "par") %>% 
  filter(par != "lp__") %>% 
  kable(digits = 2,
        booktabs = TRUE,
        caption = "b14.4の結果") %>% 
  kable_styling(latex_options = c("striped", "hold_position"))
```

続いて、Qを含めたモデルを考える。  
```{r}
b14.5 <- 
  brm(data = dat_sim,
      family = gaussian,
      w ~ 1 + e + q,
      prior = c(prior(normal(0, 0.2), class = Intercept),
                prior(normal(0, 0.5), class = b),
                prior(exponential(1), class = sigma)),
      backend = "cmdstanr",
      seed =14, file = "output/Chapter14/b14.5"
      )
```

結果は以下の通り（表\@ref(tab:res-b14-5)）。DAGの通りQとEの間に関連が生じており、その結果Eの係数もさらに0から離れていることが分かる。    
```{r res-b14-5, echo = FALSE}
posterior_summary(b14.5) %>% 
  data.frame() %>% 
  rownames_to_column(var = "par") %>% 
  filter(par != "lp__") %>% 
  kable(digits = 2,
        booktabs = TRUE,
        caption = "b14.5の結果。") %>% 
  kable_styling(latex_options = c("striped", "hold_position"))
```

Qを用いて正しい因果関係を推定するためには、以下のような多変量モデルを作成すればよい。このモデルではWとEの残差に相関がある可能性があることを示しており（これは、Uが交絡要因となっているため）、これが5章で扱ったモデルとは異なる。なお、Uを欠損値として代入する方法もあるが、それについては次の章で学ぶ。    

$$
\begin{aligned}
  \begin{bmatrix}
    W_{i}\\E_{i} 
  \end{bmatrix}
  &\sim MVNorm(
  \begin{bmatrix}
    \mu_{W,i}\\
    \mu_{E,i}
  \end{bmatrix}
  , \mathbf{\sum})\\
  \mu_{W,i} &= \alpha_{W} + \beta_{EW}E_{i}\\
  \mu_{E,i} &= \alpha_{E} + \beta_{QW}Q_{i}\\
  \mathbf{\sigma} &= \begin{bmatrix}
               \sigma_{W}&0\\0&\sigma_{E}
                      \end{bmatrix}
            \mathbf{R}
                     \begin{bmatrix}
               \sigma_{W}&0\\0&\sigma_{E}
                     \end{bmatrix}\\
  \mathbf{R} &= \begin{bmatrix}
                  1&\rho\\ \rho&1
                \end{bmatrix}\\
  \alpha_{W}, \alpha_{E} &\sim Normal(0,0.2)\\
  \beta_{EW}. \beta_{QE} &\sim Normal(0,0.5)\\
  \sigma_{W}, \sigma_{W} &\sim Exponential(1)\\
  \rho &\sim LKJcorr(2)
\end{aligned}
$$
<br />  

`brms`でモデリングする。  
```{r}
e_model <- bf(e ~ 1+q)
w_model <- bf(w ~ 1+e)

b14.6 <- 
  brm(data = dat_sim,
      family = gaussian,
      e_model + w_model + set_rescor(TRUE),
      prior = c(prior(normal(0, 0.2), class = Intercept,resp = e),
                prior(normal(0, 0.5), class = b, resp = e),
                prior(exponential(1), class = sigma, resp = e),
                prior(normal(0, 0.2), class = Intercept,resp = w),
                prior(normal(0, 0.5), class = b, resp = w),
                prior(exponential(1), class = sigma, resp = w),
                prior(lkj(2), class = rescor)),
      backend = "cmdstanr",
      seed = 14, file = "output/Chapter14/b14.6")
```

結果は以下の通り（表\@ref(tab:res-b14-6)）。うまく推定が行えていることが分かる。誤差間の相関（rescor）が大きいことは、 EとWが共通の要因から影響を受けていることを強く示唆している。   
```{r res-b14-6, echo = FALSE}
posterior_summary(b14.6) %>% 
  data.frame() %>% 
  rownames_to_column(var = "par") %>% 
  filter(par != "lp__") %>% 
  kable(digits = 2,
        booktabs = TRUE,
        caption = "b14.6の結果") %>% 
  kable_styling(latex_options = c("striped", "hold_position"))
```

それでは、今度は教育による効果があるというデータをシミュレートする。  
```{r}
set.seed(73)
n <- 500
dat_sim2 <- 
  tibble(u_sim = rnorm(n,mean=0,sd=1),
         q_sim = sample(1:4, size=n, replace=TRUE)) %>% 
  mutate(e_sim = rnorm(n, mean=u_sim + q_sim, sd=1),
         w_sim = rnorm(n, mean=-u_sim + 0.2*e_sim, sd =1)) %>% 
  mutate(w = standardize(w_sim),
         e = standardize(e_sim),
         q = standardize(q_sim))

head(dat_sim2)
```

それでは、同様に3つのモデリングを行う。  
```{r}
b14.4x <- update(b14.4,
                 newdata = dat_sim2,
                 seed =14, file = "output/Chapter14/b14.4x")

b14.5x <- update(b14.5,
                 newdata = dat_sim2,
                 seed =14, file = "output/Chapter14/b14.5x")

b14.6x <- update(b14.6,
                 newdata = dat_sim2,
                 seed =14, file = "output/Chapter14/b14.6x")
```

推定値を図示すると以下のようになる。やはり3つめのモデルでうまく推定ができたことが分かる。また、EとQの残差の相関は負になっている。これは、UがWには正に影響し、Eには負に影響していたからである。   
```{r, echo=FALSE}
res_b14.4x <- posterior_summary(b14.4x)[1:3,] %>% 
              data.frame() %>% 
              mutate(par = c("alpha[W]", "beta[EW]",
                             "sigma[W]"),
                     fit = "b14.4x")

res_b14.5x <- posterior_summary(b14.5x)[1:4,] %>% 
              data.frame() %>% 
              mutate(par = c("alpha[W]", "beta[EW]",
                             "beta[QE]","sigma[W]"),
                     fit = "b14.5x")

res_b14.6x <- posterior_summary(b14.6x)[1:7,] %>% 
              data.frame() %>% 
              mutate(par = c("alpha[E]", "alpha[W]", "beta[QE]",
                             "beta[EW]", "sigma[E]", "sigma[W]",
                             "rho"),
                     fit = "b14.6x")


bind_rows(res_b14.4x,res_b14.5x,res_b14.6x) %>% 
  ggplot(aes(x = par, y = Estimate, color = fit))+
  geom_pointrange(aes(ymin = Q2.5, ymax = Q97.5),
                     fatten =2, 
                     position = position_dodge(width =0.5))+
  scale_color_manual(values = c("orange1","navy","red4"))+
  scale_x_discrete(NULL, labels = ggplot2:::parse_safe)+
  ylab("marginal posterior")+
  coord_flip()+
  theme(axis.text.y = element_text(hjust = 0),
        axis.ticks.y = element_blank())
```

`dagitty`パッケージにはDAG内で*instrumental variable*があるか判定してくれる関数が存在する。  

```{r}
library(dagitty)

dagIV <- dagitty("dag{Q -> E <- U -> W <- E}")

instrumentalVariables(dagIV, exposure = "E", outcome = "W")
```

現実的にはある変数が*instrumental variable*かを判断することは難しい。背景となる科学的な知識に基づいて判断することが重要である。  

### Other designs  
#### Front door criterion  
以下のようなDAGがあるとする。もしXとYの因果関係を調べたいとする。もし、Zが確実にYに影響を与えているとすれば、フロントドア基準が用いて因果関係を推定することができる。    
```{r, echo = FALSE, fig.height =2}
dag_coords <-
  tibble(name = c("X", "Z", "U", "Y"),
         x    = c(1, 2, 2, 3),
         y    = c(1, 1, 1.5, 1))
  
dagify(X ~ U,
       Z ~ X,
       Y ~ U + Z,
       coords = dag_coords) %>%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_dag_point(aes(color = name == "U"),
                 shape = 21, stroke = 2, fill = "white",
                 size = 6, show.legend = F) +
  geom_dag_text(color = "black") +
  geom_dag_edges(edge_colour = "black") +
  scale_color_manual(values = c("navy", "black")) +
  theme_minimal()+
  scale_x_continuous(NULL, breaks = NULL, expand = c(0,0.2)) +
scale_y_continuous(NULL, breaks = NULL, expand = c(0,0.2)) +
  theme(aspect.ratio=1,
        panel.grid = element_blank())
```

例として、大学で形成された社会的紐帯と上院における投票行動の関連を分析した研究がある[@Cohen2014]。上院では隣の座席になった人同士で同じような投票行動をとる可能性が高いと考えられるが、席順はランダムに割り振られる。よって、席順と出身大学は同じ要因から影響を受けていないといえる。よって、もし座席が隣同士でかつ同じ出身大学の人が座席が隣でかつ同じ出身大学でない人よりも同じような投票行動をするとき、出身大学が同じであることが投票行動に影響しているということができる。
  
#### Regression discontinuity  
回帰分断デザインについては、他の本参照。  

## Social relations as correlated varying effects
ニカラグアの家庭間での贈り物の交換に関するデータを扱う[@Koster2014]。

```{r}
data("KosterLeckie")

d3 <- kl_dyads
head(kl_dyads) %>% 
  kable(booktabs = TRUE) %>% 
  kable_styling(latex_options = c("hold_position","striped"))
```

下図は、家庭AとBの間の贈り物の数をプロットしたもの。相関は`r round(cor(d3$giftsAB, d3$giftsBA),2)`と高くないが、それだけで家庭間の交換でバランスが取れていないと判断するべきではない。なぜなら、他家庭に送るプレゼントの量は各家庭の経済状況などに依存するため、これらの影響を切り離す必要があるからである。  
```{r, echo = FALSE}
d3 %>% 
  ggplot(aes(x = giftsAB, y = giftsBA))+
  geom_point(color = "navy", alpha = 1/2)+
  geom_abline(linetype=3)+
  scale_x_continuous("gifts household A to household B",
                     breaks = seq(0,100,by=20))+
  scale_y_continuous("gifts household B to household A",
                     breaks = seq(0,100,by=20))+
  coord_cartesian(xlim = c(0,100))+
  theme(aspect.ratio=1)
```

そこで、以下のモデルを考える。なお、$g_{A}$は家庭Aの贈り物を送る傾向を表すランダム効果、$r_B$は家庭Bが贈り物を受ける傾向を示すランダム効果、$d_{AB}$は各ダイアッド間での贈り物の量のばらつきを表すランダム効果である。
$$
\begin{aligned}
y_{A\to B} &\sim Poisson(\lambda_{AB})\\
log\lambda_{AB} &= \alpha + g_{A} + r_{B} + d_{AB}\\
\end{aligned}
$$
<br/>  

家庭Bに対する贈り物についても同様。  
$$
\begin{aligned}
y_{B\to A} &\sim Poisson(\lambda_{BA})\\
log\lambda_{BA} &= \alpha + g_{B} + r_{A} + d_{BA}\\
\end{aligned}
$$
<br />  

また、$g$と$r$、$d_{AB}$と$d_{BA}$の間には相関があると想定できるので、以下のようにモデリングする。  

$$
\begin{aligned}
  \begin{pmatrix}
    g_{i}\\r_{i}
  \end{pmatrix}
  &\sim 
  MVNormal
    \begin{pmatrix}
        \begin{pmatrix}
          0\\0
        \end{pmatrix}, 
        \begin{pmatrix}
          \sigma^2_{g} & \sigma_{g}\sigma_{r}\rho_{gr}\\
          \sigma_{g}\sigma_{r}\rho_{gr} & \sigma^2_{r}
        \end{pmatrix}
    \end{pmatrix}\\
  \begin{pmatrix}
    d_{ij}\\d_{ji}
  \end{pmatrix}
  &\sim 
  MVNormal
    \begin{pmatrix}
        \begin{pmatrix}
          0\\0
        \end{pmatrix}, 
        \begin{pmatrix}
          \sigma^2_{d} & \sigma^2_{d}\rho_{d}\\
          \sigma^2_{d}\rho_{d} & \sigma^2_{d}
        \end{pmatrix}
    \end{pmatrix}
\end{aligned}
$$
<br />  

それでは、モデリングを行う。`brms`パッケージではこのモデルを記述できないため、ここでは`rethinking`パッケージを用いる。  

```{r}
# kl_data <- 
#   list(
#     N            = nrow(kl_dyads),
#     N_households = max(kl_dyads$hidB), 
#     did          = kl_dyads$did,
#     hidA         = kl_dyads$hidA,
#     hidB         = kl_dyads$hidB,
#     giftsAB      = kl_dyads$giftsAB, 
#     giftsBA      = kl_dyads$giftsBA
#   )
# 
# m14.7 <- 
#   ulam( 
#     alist(
#       giftsAB ~ poisson(lambdaAB),
#       giftsBA ~ poisson(lambdaBA),
# 
#     log(lambdaAB) <- a + gr[hidA, 1] + gr[hidB, 2] + d[did, 1] ,
#     log(lambdaBA) <- a + gr[hidB, 1] + gr[hidA, 2] + d[did, 2] ,
# 
#       a ~ normal(0, 1),
# 
#     vector[2]:gr[N_households]~multi_normal(0,Rho_gr,sigma_gr),
#       Rho_gr ~ lkj_corr(4),
#       sigma_gr ~ exponential(1),
# 
#       transpars> matrix[N,2]:d <-
#         compose_noncentered(rep_vector(sigma_d, 2), L_Rho_d, z),
#       matrix[2,N]:z ~ normal(0, 1),
#       cholesky_factor_corr[2]:L_Rho_d ~ lkj_corr_cholesky(8),
#       sigma_d ~ exponential(1),
#     gq> matrix[2, 2]:Rho_d <<- Chol_to_Corr(L_Rho_d)
#     ),
#     data = kl_data,
#     chains = 4, cores = 4, iter = 2000
#   )

m14.7 <- readRDS("output/Chapter14/m14.7.rds")
```

$\rho_{gr}$と$\sigma^2_{g}$、$\sigma^2_{r}$の推定値は以下の通り（表\@ref(tab:res-m14-7)）。結果、多くの贈り物をする人は、あまり贈り物をもらわない傾向にあることが分かった。また、受け取る量よりも受け取る量のばらつきの方が大きい。  
```{r res-m14-7, echo = FALSE}
precis(m14.7, depth=3, pars = c("Rho_gr", "sigma_gr")) %>% 
  data.frame() %>% 
  rownames_to_column(var = "par") %>% 
  kable(booktabs =T,
        digits=2,
        caption  = "m14.7の結果") %>% 
  kable_styling(latex_options = c("striped","hold_position"))
```

各家庭の事後平均を示したのが下図である。楕円は、50%信用区間を表す。  
```{r, echo = FALSE}
post <- extract.samples(m14.7)

g <- sapply(1:25, function(i) post$a + post$gr[,i,1])
r <- sapply(1:25, function(i) post$a + post$gr[,i,2])

rbind(exp(g), exp(r)) %>% 
  data.frame() %>% 
  set_names(1:25) %>% 
  mutate(par = rep(c("g","r"), each = n()/2),
         iter = rep(1:4000, times =2)) %>% 
  pivot_longer(-c(par, iter), names_to = "household") %>% 
  pivot_wider(names_from = par, values_from = value) %>% 
  group_by(household) %>% 
  mutate(mu_g = mean(g),
         mu_r = mean(r)) %>% 
  nest(data = c("g","r","iter")) %>% 
  ggplot(aes(group = household))+
  geom_abline(linetype =2, alpha = 1/3)+
  stat_ellipse(data = . %>%  unnest(data),
               aes(x=g, y=r),
               type = "norm", level = .5, size=1/2, alpha = 1/2,
               color = "black")+
  geom_point(aes(x=mu_g, y = mu_r), color = "navy")+
  labs(x = "generalized giving",
       y = "generalized receiving") +
  theme_classic()+
  coord_equal(xlim = c(0, 8.5),
              ylim = c(0, 8.5))

```

$\sigma^2_{d}$と$\rho_{d}$の推定値は以下の通り（表\@ref(tab:res-m14-7-2)）。
```{r res-m14-7-2}
precis(m14.7, depth = 3, pars = c("Rho_d", "sigma_d")) %>% 
  data.frame() %>% 
  rownames_to_column(var = "par") %>% 
  kable(booktabs =T,
        digits=2,
        caption  = "m14.7の結果2 ") %>% 
  kable_styling(latex_options = c("striped","hold_position"))
```

下図は、事後平均をプロットしたものである。$d_{ij}$と$d_{ji}$の間には強い相関があることが分かる。すなわち、家庭間の贈与量はバランスが取れている（家庭AがBにあげる量が少なければ、BがAにあげる量も少ない）。また、ダイアッド間でばらつきが大きいことも分かる。この結果は、互恵性が成立していることを示している。    
```{r, echo = FALSE}
tibble(dy1 = map_dbl(post$d[,,1] %>% data.frame() %>%
                   set_names(1:300),~mean(.)),
       dy2 = map_dbl(post$d[,,2] %>% data.frame() %>%
                   set_names(1:300),~mean(.))) %>% 
  ggplot(aes(x = dy1, y = dy2))+
  geom_point(color = "navy", shape=1)+
  labs(x = "household A in dyad",
       y = "household B in dyad") +
  theme_classic()+
  geom_abline(linetype=2)+
  geom_hline(yintercept =0, linetype=2)+
  geom_vline(xintercept =0, linetype=2)+
  coord_equal(xlim = c(-2, 3.5),
              ylim = c(-2, 3.5))
```

## Continuous categories and the Gaussian process  
ここまでは、ランダム効果は順序のない、不連続なカテゴリーに対して適応されていた。もし、連続的なカテゴリー（年齢、身長、収入など）をランダム効果に組み込む場合にはどうすればよいだろうか？  
このような場合に用いることができるのがガウス過程回帰（**Gaussian process regression**）である。  

### Example: Spatial autocorrelation in Oceanic tools  
11章でオセアニア諸国の道具数についてモデリングを行ったとき、他国との交渉頻度を低いか高いかの2カテゴリーに分類した。しかし、このモデルでは、交渉相手国がどの国なのか（小さい国なのか大きい国なのか）が考慮されていない。また、道具が各国間で交換されているのであれば、各国の道具数は独立ではないという問題点もある。また、各国の地理的距離（近い国ほど同じような素材がある）も考慮する必要がある。
以上から、各国間の地理的距離を考慮したモデルを考える必要がある。**ガウス過程モデル**ではモデルに各国の距離マトリックスを組み込むことでこれを実現する。  

```{r}
data("islandsDistMatrix")

d_mat <- islandsDistMatrix
colnames(d_mat) <- c("Ml", "Ti", "SC", "Ya", "Fi", "Tr", "Ch", "Mn", "To", "Ha")
```

各国間の距離は以下の通り。  
```{r, echo = FALSE, fig.height = 4.5}
d_mat %>% 
  data.frame() %>% 
  rownames_to_column("row") %>% 
  pivot_longer(-row, names_to = "column", values_to = "distance") %>% 
  mutate(column = factor(column, levels = colnames(d_mat)),
         row = factor(row, levels = rownames(d_mat)) %>% fct_rev(),
         label = formatC(distance, format = "f", digits =2)) %>% 
  ggplot(aes(x = column, y = row))+
  geom_raster(aes(fill = distance))+
  geom_text(aes(label = label), color = "white")+
  scale_x_discrete(NULL, position = "top", expand = c(0, 0)) +
  scale_y_discrete(NULL, expand = c(0, 0))+
  theme(axis.ticks = element_blank())
```

モデル式は以下の通り。距離マトリックスをランダム切片に加える。
$$
\begin{aligned}
  T_{i} &\sim Poisson(\lambda_{i})\\
  \lambda_{i} &= exp(k_{society[i]})\alpha P^{\beta}_{i}/ \gamma\\
  \begin{pmatrix}
    k_{1}\\k_{2}\\k_{3}\\...\\k_{10}
  \end{pmatrix} 
    &\sim Normal 
  \begin{pmatrix}
      \begin{pmatrix}
          0\\0\\0\\...\\0
      \end{pmatrix}, 
          \mathbf{K}
  \end{pmatrix}\\
  \mathbf{K_{ij}} &= \eta^2 exp(\rho^2D^2_{ij}) + \delta_{ij}\sigma^2\\
\end{aligned}
$$
<br />  

なお、$K_{ij}$は国$i$と国$j$の共分散を表す。$D_{ij}$は国間の距離なので、$K_{ij}$は国家間の距離の二乗が大きくなるほど共分散は小さくなる。$\rho$はこの減少の速度を表す。距離の二乗を用いたのは、それが実際の共分散の減少をよりよく表していると考えられるためである。下図は、$D_{ij}$に応じて$K_ij$がどのように変化するかを示したものである。  

```{r, echo = FALSE}
tibble(x = seq(0,4,length.out =100),
       linear = exp(-1*x),
       squared = exp(-1*x^2)) %>% 
  ggplot(aes(x=x))+
  geom_line(aes(y = linear), linetype="dashed")+
  geom_line(aes(y = squared))+
  scale_y_continuous("correlation",breaks =seq(0,1,by=0.5))+
  xlab("distance")+
  theme(aspect.ratio=1)
```
<br />  

$\eta^2$は最大の共分散を、$\delta_{ij}\sigma^2$は$i =j$のときの共分散の追加分を示す。$\delta_{ij}$は$i=j$のときに1、それ以外のときに0をとる関数で、$\sigma$は国内のばらつきを示す。今回は各国につき1つしかデータがないので関係ない。$\eta^2$と$\rho^2$の事前分布を以下のとおりとする。  

$$
\begin{aligned}
  \eta^2 &\sim Exponential(2)\\
  \rho^2 &\sim Exponential(0.5)
\end{aligned}
$$
<br />  

`brms`パッケージでは、`gp()`を用いることでガウス過程を扱うことができる。この関数内では、各国の緯度と経度を用いて$D_{ij}$を算出する。`scale = TRUE`は$D_{ij}$の最大値を1とする。今回は`FALSE`にする。データ上の緯度と経度は十進角（decimal degree）で記されているのでkmに直すために0.11132をかける。
```{r}
data("Kline2")
d4 <- Kline2 %>% 
  mutate(lat_adj = lat*0.11132,
         lon2_adj = lon2*0.11132)

d4 %>% 
  dplyr::select(culture, lat, lon2, lat_adj:lon2_adj) %>% 
  kable(booktabs = TRUE,
        digits =2) %>% 
  kable_styling(latex_options = "striped")
```

それでは、モデリングを行う。
```{r}
b14.8 <- 
  brm(data =d4,
      family = poisson(link = "identity"),
      bf(total_tools ~ exp(a)*population^b/g,
         a ~ 1 + gp(lat_adj, lon2_adj, scale = FALSE),
         b + g ~ 1,
         nl = TRUE),
      prior = c(prior(normal(0, 1), nlpar = a),
                prior(exponential(1), nlpar = b, lb = 0),
                prior(exponential(1), nlpar = g, lb = 0),
                prior(inv_gamma(2.874624, 2.941204), 
                      class = lscale, 
                      coef = gplat_adjlon2_adj, nlpar = a),
                prior(exponential(2), class = sdgp, 
                      coef = gplat_adjlon2_adj, nlpar = a)),
      iter = 3000, warmup = 2000, chains = 4, cores = 4,
      seed = 14, sample_prior = TRUE,
      backend = "cmdstanr",
      file = "output/Chapter14/b14.8")
```

結果は以下の通り（表\@ref(tab:res-b14-8)）。地理的な情報を考慮しても、人口が道具数に影響を与えていることが示唆される。
```{r res-b14-8, echo = FALSE}
posterior_summary(b14.8) %>% 
  data.frame() %>% 
  kable(digits = 2,
        booktabs = TRUE,
        caption = "b14.8の結果") %>% 
  kable_styling(latex_options = c("striped", "hold_position"))
```

`b_a_Intercept`の推定値が教科書と異なるのは、パラメータ化の仕方が少し異なるためである。指数関数をとってやると教科書の値とほとんど同じになる（信用区間は少し違うが）。    

```{r}
fixef(b14.8, probs = c(.055,.945))["a_Intercept",c(1,3,4)] %>% 
  exp()
```

`brms`パッケージでは、ガウス過程は以下のようにパラメータ化を行う。$k(x_{i},x_{j})$は教科書の$\mathbf{K_{ij}}$であり、$||x_{i}-x_{i}||^2$は$D_{ij}^2$である。さらに、$sdgp^2$は$\eta^2$であり、$\rho^2 = 1/(2lscale^2)$である。  

$$
k(x_{i},x_{j}) = sdgp^2 exp(-||x_{i}-x_{i}||^2/(2lscale^2))
$$
<br />  

`brms`では$sdgp^2$ではなく$sdgp$が、$lscale^2$ではなく $lscale$が推定される。これは、以下の変換によって教科書と同じパラメータの推定値が得られる。$\eta$はほとんど同じ値だが、$\rho$が大きく異なる。これは、教科書とは異なる事前分布を用いたため？

```{r}
post <-
  posterior_samples(b14.8) %>% 
  mutate(etasq = sdgp_a_gplat_adjlon2_adj^2,
         rhosq = 1 / (2 * lscale_a_gplat_adjlon2_adj^2)) 

post %>% 
  pivot_longer(etasq:rhosq, values_to = "value") %>%
  dplyr::select(name, value) %>% 
  group_by(name) %>% 
  mean_hdi(value, .width=.89) %>% 
  mutate(across(where(is.numeric), ~round(.,digits=2)))
```

共分散$\mathbf{K_{ij}}$の事前分布と事後分布は以下のようになる。ばらつきが大きいことが分かる。    
```{r, echo = FALSE}
set.seed(123)

prior_samples(b14.8) %>% 
  data.frame() %>% 
  mutate(iter  = 1:n(),
         etasq = sdgp_a_gplat_adjlon2_adj^2,
         rhosq = 1 / (2 * lscale_a__1_gplat_adjlon2_adj^2)) %>% 
  slice_sample(n = 100) %>%
  tidyr::expand(nesting(iter, etasq, rhosq),
         x = seq(from = 0, to = 10, by = .05)) %>% 
  mutate(covariance = etasq * exp(-rhosq * x^2)) %>% 
  group_by(x) %>% 
  mutate(mean = mean(covariance)) %>% 
  ggplot(aes(x = x)) +
  geom_line(aes(y = covariance, group = iter),
            size = 1/4, alpha = 1/4, color = "grey2") +
  geom_line(aes(y = mean), size = 1.2)+
  scale_x_continuous("distance (thousand km)", expand = c(0, 0),
                     breaks = 0:5 * 2) +
  coord_cartesian(xlim = c(0, 10),
                  ylim = c(0, 2)) +
  labs(subtitle = "Gaussian process prior") -> p1

post %>% 
  mutate(iter = 1:n()) %>% 
  slice_sample(n=100) %>% 
  tidyr::expand(nesting(iter, etasq, rhosq),
         x = seq(0,10, by=0.05)) %>% 
  mutate(covariance = etasq*exp(-rhosq*x^2)) %>% 
  group_by(x) %>% 
  mutate(mean = mean(covariance)) %>% 
  ggplot(aes(x = x))+
  geom_line(aes(y = covariance,group = iter),alpha=1/4,
            color = "grey2")+
  geom_line(aes(y=mean),size=1.2)+
  scale_x_continuous("distance (thousand km)", 
                     breaks = seq(0,10,by=2))+
  coord_cartesian(ylim = c(0,2))+
  theme(aspect.ratio=1)+
  labs(subtitle = "Gaussian process posterior") -> p2

p1+p2
```

共分散行列の事後推定値は以下のとおりである。  
```{r}
k <- matrix(0, nrow =10, ncol =10)

for(i in 1:10){
  for(j in 1:10){
   k[i,j] <- median(post$etasq)*exp(-median(post$rhosq)*
                                      islandsDistMatrix[i,j]^2)
   diag(k) <- median(post$etasq) + 0.01
  }
}
rownames(k) <- rownames(d_mat)
colnames(k) <- colnames(d_mat)
```


```{r, echo = FALSE, fig.heght = 4.5}
k %>% 
  data.frame() %>%
  set_names(colnames(d_mat)) %>% 
  rownames_to_column("row") %>% 
  pivot_longer(-row, names_to = "column",
               values_to = "cov") %>% 
  mutate(column = factor(column, levels = colnames(d_mat)),
         row= factor(row,levels = rownames(d_mat))%>%fct_rev(),
         label  = formatC(cov, format = 'f', digits = 2)) %>% 
  ggplot(aes(x = column, y = row))+
  geom_raster(aes(fill = cov))+
  geom_text(aes(label = label), color = "white")+
  scale_x_discrete(NULL, position = "top", expand = c(0, 0)) +
  scale_y_discrete(NULL, expand = c(0, 0))+
  theme(axis.ticks = element_blank())
```

相関行列は以下の通り。行列の左上の小さな社会が強い相関を持っていることが分かる。一方、ハワイ（Ha）は他の地域から離れているのでゼロである。  
```{r}
rho <- round(cov2cor(k),2)

colnames(rho) <- c("Ml", "Ti", "SC", "Ya", "Fi", "Tr", "Ch", "Mn", "To", "Ha")
rownames(rho) <- colnames(rho)
```

```{r, echo = FALSE, fig.height = 4.5}
rho %>% 
  data.frame() %>%
  rownames_to_column("row") %>% 
  pivot_longer(-row, names_to = "column",
               values_to = "cor") %>% 
  mutate(column = factor(column, levels = colnames(rho)),
         row= factor(row,levels = rownames(rho))%>%fct_rev(),
         label  = formatC(cor, format = 'f', digits = 2)) %>% 
  ggplot(aes(x = column, y = row))+
  geom_raster(aes(fill = cor))+
  geom_text(aes(label = label), color = "white")+
  scale_x_discrete(NULL, position = "top", expand = c(0, 0)) +
  scale_y_discrete(NULL, expand = c(0, 0))+
  theme(axis.ticks = element_blank())
```

```{r, echo = FALSE}
tidy_rho <-
  rho %>% 
  data.frame() %>% 
  rownames_to_column("row") %>%
  bind_cols(d4 %>% dplyr::select(culture, logpop, total_tools,
                                 lon2, lat)) %>% 
  pivot_longer(Ml:Ha,
               names_to = "col",
               values_to = "cor") %>% 
  mutate(group = str_c(pmin(row, col), pmax(row, col))) %>% 
  dplyr::select(row, col, group, culture, everything())

tidy_rho %>% 
  ggplot(aes(x = lon2, y = lat)) +
  geom_point(data = d4, aes(size = logpop), color = "navy")+
  geom_line(aes(group = group, alpha = cor^2),
            color = "grey30", size = 1)+
  scale_alpha_continuous(range =c(0,1))+
  geom_text_repel(data = d4, aes(label = culture),
                  seed = 13, point.padding = 1, size = 2.75)+
  labs(subtitle = "A. Among societies in geographic space\n",
       x = "longitude",
       y = "latitude") +
  coord_cartesian(xlim = range(d4$lon2),
                  ylim = range(d4$lat)) +
  theme(legend.position = "none",
        aspect.ratio=1) -> p3
```

```{r, echo = FALSE}
f <- post %>% 
  tidyr::expand(logpop = seq(6,14,length.out=30),
         nesting(b_a_Intercept,b_b_Intercept,b_g_Intercept)) %>% 
  mutate(pop = exp(logpop)) %>% 
  mutate(lambda = exp(b_a_Intercept)*pop^b_b_Intercept/b_g_Intercept) %>% 
  group_by(logpop) %>% 
  median_qi(lambda,.width = .8)

tidy_rho %>% 
  ggplot(aes(x=logpop))+
  geom_line(data =f, aes(y=lambda),linetype=1)+
  geom_ribbon(data = f,
            aes(y = lambda, ymin = .lower, ymax = .upper),
            linetype =2, fill = "transparent", color = "black")+
  geom_point(data = d4, aes(y = total_tools, 
                 size = logpop), color = "navy")+
  geom_line(aes(y = total_tools, group = group, alpha = cor^2),
            color = "grey30", size = 1)+
  scale_alpha_continuous(range =c(0,1))+
  geom_text_repel(data = d4, aes(y = total_tools,
                                 label = culture),
                  seed = 13, point.padding = 1, size = 2.75)+
  labs(subtitle = "B. Shown against the relation between\ntotal tools and log pop\n",
       x = "log popolation",
       y = "total tools")+
  coord_cartesian(xlim = range(d4$logpop),
                  ylim = range(d4$total_tools)) +
  theme(legend.position = "none",
        aspect.ratio=1) -> p4
  
```

モデルの推定結果を図示したものが以下である。地理的に近い地域ほど事後平均が強く相関しており（A）、道具数も類似していることが読み取れる（B）。
```{r, echo = FALSE}

p3|p4
```

### Example: Phylogenetic distance  
空間的な距離だけでなく、時間的な距離に対しても同様の分析を施すことができる。例えば、系統上の距離を考慮した分析を施すことで複数の種を含むデータをうまく扱うことができる。系統関係は因果関係に2つの影響を与えうる。  

(1) 最近分岐した種は類似した形質を多く持つ（まだ短時間しか異なる淘汰圧にさらされていないため）。  
(2) 系統的な距離は、種間の共変動を生み出す観測できない要因の代わり（proxy）として用いることができる。例えば、鳥類には空を飛行することに起因する類似の要因が影響を与えている可能性が高い。  

集団サイズ(G)と脳容量(B)の関係を考える。社会脳仮説に従えば、集団サイズが大きいほど脳容量も大きいと予測される。この因果関係をDAGで表すと以下のようになる。添字は進化史上の異なる時点を表す。すなわち、$G_{1}$と時点1における集団サイズを、$G_{2}$は時点2における集団サイズを表す。また、Uは未観測の要因を表す。   
しかし、現実的には$U$をコントロールできない。また、$G_{1}$や$B_{1}$も知ることができない。
```{r, echo = FALSE, fig.height = 3}
library(ggdag)

dag_coords <- 
  tibble(name = c("G1", "B1", "U1", "G2", "B2", "U2"),
         x    = rep(1:2, each = 3),
         y    = rep(c(1.5,1,0.5), times = 2))

dagify(G2 ~ G1 + U1,
       B2 ~ G1 + B1 + U1,
       U2 ~ U1,
       coords = dag_coords) %>% 
  tidy_dagitty() %>% 
  mutate(color = ifelse(name %in% c("G1", "B1"), "a",
                        ifelse(name %in% c("G2", "B2"), 
                               "b", "c"))) %>% 
  ggplot(aes(x=x,y=y,xend =xend,yend=yend))+
  geom_dag_point(aes(color = color),
                 shape =21, stroke=2,fill = "white",size=7,
                 show.legend = FALSE)+
  geom_dag_text(color = "black", parse=TRUE,
                label = c("B[1]", "G[1]",
                          "U[1]", "B[2]", 
                          "G[2]", "U[2]")) +
  geom_dag_edges(edge_colour = "black") +
  scale_color_manual(values = c("lightblue", "orange","grey")) +
  theme_minimal()+
  scale_x_continuous(NULL, breaks = NULL, expand = c(0,0.2)) +
  scale_y_continuous(NULL, breaks = NULL, expand = c(0,0.2)) +
  theme(aspect.ratio=1,
        panel.grid = element_blank())
```

このように観測できない過去の要因の影響を知るために、系統関係を用いることができる。DAGで表すと以下のようになる。Mは体重を示し、集団サイズと脳容量の両方に影響していると考えられる。未観測変数Uはいずれにも影響を与えていると考えられる。また系統的距離PはUに影響していると考えられる。バックドア基準を満たすためには、MとUで条件付けする必要がある。Mは説明変数に加えることで可能である。またUもPを用いて**phylogenetic regression**を行うことで統制可能である。  
```{r, echo = FALSE, fig.height = 2.5}
dag_coords <- 
  tibble(name = c("G", "M", "U", "B", "P"),
         x    = c(1,2,2,3,3),
         y    = c(3,2,1,3,1))

dagify(G ~ M + U,
       B ~ G + M + U,
       M ~ U,
       U ~ P,
       coords = dag_coords) %>% 
  ggplot(aes(x=x,y=y,xend =xend,yend=yend))+
  geom_dag_point(aes(color = name == "U"),
                 shape =21, stroke=2,fill = "white",size=6,
                 show.legend = FALSE)+
  geom_dag_text(color = "black", 
                parse=TRUE) +
  geom_dag_edges(edge_colour = "black") +
  scale_color_manual(values = c("orange1", "grey")) +
  theme_minimal()+
  scale_x_continuous(NULL, breaks = NULL, expand = c(0,0.2)) +
  scale_y_continuous(NULL, breaks = NULL, expand = c(0,0.2)) +
  theme(aspect.ratio=1,
        panel.grid = element_blank())
```

それでは、実際にモデリングを行っていく。霊長類の系統樹を以下に示す。以下の分析では、この系統樹を用いて未観測要因Uをモデリングするとともに、分類群ごとの種数をコントロールする（例えば、キツネザルは他のサルに比べてデータが多いなど）。  
```{r}
data("Primates301")
data("Primates301_nex")
```

```{r, echo = FALSE, fig.height =5}
library(ape)
library(ggtree)

Primates301_nex %>%
  ggtree(layout = "circular", size = 1/4, color = "grey3") + 
  geom_tiplab(size = 5/3, color = "grey2")
```

系統関係を考慮したモデリングを行うに、まずはそれを考慮しない以下のモデルを考える。$\mathbf{S}$は分散共分散行列を表し、$\mathbf{I}$は単位行列である。すなわち、このモデルでは共分散が0であることを想定しているので、通常の回帰分析と同じである。  

$$
\begin{aligned}
  \mathbf{B} &\sim MVNormal(\mu, \mathbf{S})\\
  \mu_{i} &= \alpha + \beta_{G} G_{i} + \beta_{M} M_{i}\\
  \mathbf{S} &= \sigma^2\mathbf{I}
\end{aligned}
$$
<br />  

それでは、モデリングを行う。
```{r}
d5 <- 
  Primates301 %>% 
  mutate(name = as.character(name)) %>% 
  drop_na(group_size, body, brain) %>% 
  mutate(m = log(body) %>% standardize(),
         b = log(brain) %>% standardize(),
         g = log(group_size) %>% standardize())
```

```{r}
b14.9 <- 
  brm(data = d5,
      family = gaussian,
      b ~ 1 + g + m,
      prior = c(prior(student_t(3,0,2.5),class = Intercept),
                prior(student_t(3,0,2.5), class = b),
                prior(exponential(1), class = sigma)),
      backend = "cmdstanr",
      seed =14, file = "output/Chapter14/b14.9"
      )
```

結果は以下の通り(表\@ref(tab:res-b14-9))。集団サイズと体重が脳容量に影響を与えているように見える。しかし、このモデルではバイアスを取り除くことができていないため、因果推論を行うことができない。    
```{r res-b14-9, echo = FALSE}
posterior_summary(b14.9) %>% 
  data.frame() %>% 
  rownames_to_column(var = "par") %>% 
  filter(par != "lp__") %>% 
  kable(digits = 2,
        booktabs = TRUE,
        caption = "b14.9の結果。") %>% 
  kable_styling(latex_options = c("striped", "hold_position"))
```

それでは、以下では2種類の**phylogenetic regression**を行う。どちらのモデルでも、先ほどのモデルの分散共分散行列$\mathbf{S}$を系統的距離に基づいて変えるだけである。  
1つ目のモデルは、ブラウン運動（正規分布のランダムウォーク）に基づいて系統樹を解釈する。この方法では、種間の共分散が系統的距離に比例して小さくなることを仮定する。実際は、系統樹の異なる場所では進化速度が異なるはずだが、それについては考慮しない。Rでは`ape`パッケージを用いることで系統的距離を算出できる。  
```{r}
library(ape)
spp_obs <- d5$name

d6 <- Primates301_nex
tree_trimmed <- keep.tip(d6, spp_obs)
Rbm <- corBrownian(phy = tree_trimmed)

V <- vcv(Rbm)
Dmat <- cophenetic(tree_trimmed)
```

以下の図から、共分散は距離の逆数であることが分かる。
```{r, echo = FALSE}
full_join(
  Dmat %>% 
    as_tibble(rownames = "row") %>% 
    pivot_longer(-row,
                 names_to = "col",
                 values_to = "distance"),
  V %>% 
    as_tibble(rownames = "row") %>% 
    pivot_longer(-row,
                 names_to = "col",
                 values_to = "covariance"),
  by = c("row", "col")) %>% 
  ggplot(aes(x=distance, y = covariance))+
  geom_point(alpha = 1/6)+
  labs(subtitle = "These variables are the\ninverse of one another.",
       x = "phylogenetic distance", 
       y = "covariance")+
  theme(aspect.ratio=1)
```

それでは、モデリングを行う。`brms`パッケージでは、`fcor()`で既知の共分散行列をモデルに組み込む。  

```{r}
## 相関行列に変換
R <- V[spp_obs, spp_obs]/max(V)

## モデリング 
b14.10 <- 
  brm(data = d5,
      data2 = list(R=R),
      family = gaussian,
      b ~ 1 + m + g + fcor(R),
      prior = c(prior(student_t(3,0,2.5),class = Intercept),
                prior(student_t(3,0,2.5), class = b),
                prior(exponential(1), class = sigma)),
      backend = "cmdstanr",
      seed =14, file = "output/Chapter14/b14.10")
```

結果は以下の通り（表\@ref(tab:res-b14-10)）。集団サイズの影響がほとんど0になっていることが分かる。この結果から、近縁種ほど脳容量が類似しており、そのことによって集団サイズとの間に疑似相関が生じていたことが示唆される。  
```{r res-b14-10, echo = FALSE}
posterior_summary(b14.10) %>% 
  data.frame() %>% 
  rownames_to_column(var = "par") %>% 
  filter(par != "lp__") %>% 
  kable(digits = 2,
        booktabs = TRUE,
        caption = "b14.10の結果。") %>% 
  kable_styling(latex_options = c("striped", "hold_position"))
```

ブラウン運動モデルは、ガウス過程の特殊例である。ブラウン運動モデルを改良するため、**Ornstein-Uhlenbeck Process**（OU process）が用いられることがある。このモデルでは、系統的距離と共分散の間に以下のような非線形な関係を想定する。  

$$
K_{i,j} = \eta^2 exp(-\rho^2 D_{ij})
$$
<br />  

前節のオセアニアの道具モデルと違う点は、距離が二乗されていないことである。OU processもガウス過程の一種である。現在`brms`ではOU過程をサポートしていないので、`rethinking`パッケージでモデリングを行う。  

```{r}
dat_list <- 
  list(
    N_spp = nrow(d5),
    M     = standardize(log(d5$body)),
    B     = standardize(log(d5$brain)),
    G     = standardize(log(d5$group_size)), 
    Imat  = diag(nrow(d5)),
    V     = V[spp_obs, spp_obs],
    R     = V[spp_obs, spp_obs] / max(V[spp_obs, spp_obs]),
    Dmat  = Dmat[spp_obs, spp_obs] / max(Dmat)
  )

m14.11 <- 
  ulam( 
    alist(
      B ~ multi_normal(mu, SIGMA),
      mu <- a + bM * M + bG * G,
      matrix[N_spp,N_spp]: SIGMA <- cov_GPL1(Dmat, etasq, rhosq, 0.01), 
      a ~ normal(0, 1),
      c(bM,bG) ~ normal(0, 0.5),
      etasq ~ half_normal(1, 0.25),
      rhosq ~ half_normal(3, 0.25)
    ), 
    data = dat_list, 
    chains = 4, cores = 4)
```

結果は以下の通り（表\@ref(tab:res-b14-11)）。集団サイズは小さいながらも、脳容量に影響を与えていることが分かる。    
```{r res-b14-11}
precis(m14.11) %>% 
  data.frame() %>% 
  rownames_to_column(var = "par") %>% 
  kable(digits = 2,
        booktabs = TRUE,
        caption = "b14.11の結果。") %>% 
  kable_styling(latex_options = c("striped", "hold_position"))
```

$K_{ij}$の事前分布と事後分布を描いたのが下図である。推定結果から、いずれの系統的距離においても種間のばらつきが小さいことが分かる。
```{r, echo = FALSE}
post <- extract.samples(m14.11)

set.seed(14)

f_post <- 
  post %>% 
  data.frame() %>% 
  mutate(iter = 1:n()) %>% 
  tidyr::expand(nesting(iter, etasq, rhosq),
                d_seq = seq(0,1,length.out=100)) %>% 
  mutate(k_post = etasq*exp(-rhosq*d_seq)) %>% 
  group_by(d_seq) %>% 
  mean_hdi(k_post, width = .89)

f_prior <- 
  tibble(eta = abs(rnorm(1e5, mean=1, sd=0.25)),
         rho = abs(rnorm(1e5, mean=3, sd = 0.25))) %>% 
  tidyr::expand(nesting(eta, rho), 
              d_seq = seq(from = 0, to = 1, length.out =100)) %>%
    mutate(k = eta * exp(-rho * d_seq)) %>% 
    group_by(d_seq) %>% 
    mean_hdi(k, .width = .89)

full_join(f_post, f_prior, by = "d_seq") %>% 
  ggplot(aes(x=d_seq))+
  geom_ribbon(aes(ymin = k_post.lower,
                  ymax = k_post.upper),
              fill = "navy", alpha = 1/6)+
  geom_line(aes(y = k_post), color = "navy")+
  geom_ribbon(aes(ymin = .lower,
                  ymax = .upper),
              fill = "grey2", alpha = 1/6)+
  geom_line(aes(y = k), color = "black")+
  annotate(geom = "text",
           x = c(0.2, 0.5), y = c(0.1,0.5),
           label = c("posterior", "prior"),
           color = c("navy", "black"))+
  labs(x = "phylogenetic distance", 
       y = "covariance") +
  ylim(0, 1.5)+
  theme(aspect.ratio=1)
```

## Practice  
### 14M1  
> Repeat the café robot simulation from the beginning of the chapter. This time, set rho to zero, so that there is no correlation between intercepts and slopes. How does the posterior distribution of the correlation reflect this change in the underlying simulation?  

本章冒頭のロボットの例で、ランダム切片とランダム傾きの間の相関をゼロにしてみる。  
```{r}
a <- 3.5         # averange morning wait time  
b <- (-1)          # average difference afternoon wait time  
sigma_a <- 1     # std dev in intercepts   
sigma_b <- 0.5   # std dev in slopes  
rho <- 0     # correlation between interecpts and slopes

mu <- c(a,b) 
cov_ab <- sigma_a*sigma_b*rho #共分散
sigma <- matrix(c(sigma_a^2, cov_ab, 
                  cov_ab, sigma_b^2), ncol=2)　# 分散共分散行列
```

```{r}
n_cafes <- 20

set.seed(5)

vary_effects <- 
  MASS::mvrnorm(n_cafes, mu, sigma) %>% 
  data.frame() %>% 
  set_names("a_cafe", "b_cafe")

n_visits <- 10
sigma_y <- 0.5

set.seed(22)

dat <- 
  vary_effects %>% 
  mutate(cafe = 1:n()) %>% 
  tidyr::expand(nesting(cafe, a_cafe, b_cafe),
         visits = 1:n_visits) %>% 
  mutate(afternoon = rep(0:1, times = n()/2)) %>% 
  mutate(mu = a_cafe + b_cafe*afternoon) %>% 
  mutate(wait = rnorm(n=n(), mean=mu, sd=sigma_y))

```

それでは、モデリングを行う。  
```{r}
b14M1 <- 
  brm(data =dat,
      family = gaussian,
      wait ~ 1 + afternoon + (1+afternoon|cafe),
      prior = c(prior(normal(5,2), class = Intercept),
                prior(normal(-1,0.5), class = b),
                prior(exponential(1), class = sigma),
                prior(exponential(1), class =sd),
                prior(lkj(2), class = cor)),
      backend = "cmdstanr",
      seed = 155, file = "output/Chapter14/b14M1")
```

推定値もほとんどゼロになる。
```{r}
posterior_summary(b14M1) %>% 
  data.frame() %>% 
  rownames_to_column(var = "par") %>% 
  filter(str_detect(par,"cor")) %>% 
  kable(digits = 2,
        booktabs = TRUE) %>% 
  kable_styling(latex_options = c("striped", "hold_position"))
```

### 14M2  
> Fit this multilevel model to the simulated café data:  

$$
\begin{aligned}
  W_{i} &\sim Normal(\mu_{i}, \sigma)\\
  \mu_{i} &= \alpha_{cafe[i]} + \beta_{cafe[i]}A_{i}\\
    \alpha_{cafe} &\sim Normal(\alpha, \sigma_{\alpha}) \\
    \beta_{cafe}  &\sim Normal(\beta, \sigma_{\beta})\\
  \alpha &\sim Normal(0,10)\\
  \beta &\sim Normal(0,10)\\
  \sigma &\sim HalfCauchy(0,1)\\
  \sigma_{\alpha} &\sim HalfCauchy(0,1)\\
  \sigma_{\beta} &\sim HalfCauchy(0,1)\\
\end{aligned}
$$

> Use WAIC to compare this model to the model from the chapter, the one that uses a multi-variate Gaussian prior. Explain the result.  

本章冒頭のシミュレーションデータで、ランダム切片とランダム傾きの間に相関を仮定しない（それぞれが独立に得られる）モデルを考える。`brms`では、`(1+afternoon||cafe)`のように書くことで、ランダム切片とランダム傾きの相関を考慮しないモデルを作れる。  
```{r}
b14M2 <- 
  brm(data =d,
      family = gaussian,
      wait ~ 1 + afternoon + (1+afternoon||cafe),
      prior = c(prior(normal(0,10), class = Intercept),
                prior(normal(0,10), class = b),
                prior(exponential(1), class = sigma),
                prior(exponential(1), class =sd)),
      backend = "cmdstanr",
      seed = 155, file = "output/Chapter14/b14M2")  
```

`b14.1`の結果と比較してみる。推定結果に大きな違いはなさそう。    
```{r, echo =  FALSE}
posterior_summary(b14.1) %>% 
  data.frame() %>% 
  rownames_to_column(var = "par") %>%
  filter(!str_detect(par, "r_cafe\\[")) %>% 
  filter(par != "lp__") %>% 
  kable(digits = 2,
        booktabs = TRUE,
        caption = "b14.1の結果") %>% 
  kable_styling(latex_options = c("striped", "hold_position"))
```

```{r, echo = FALSE}
posterior_summary(b14M2) %>% 
  data.frame() %>% 
  rownames_to_column(var = "par") %>%
  filter(!str_detect(par, "r_")) %>% 
  filter(par != "lp__") %>% 
  kable(digits = 2,
        booktabs = TRUE,
        caption = "b14M2の結果。") %>% 
  kable_styling(latex_options = c("striped", "hold_position"))
```

```{r, echo = FALSE}
coef <- coef(b14.1)
coef_M2 <- coef(b14M2)

base <- coef$cafe[,1,] %>% 
  data.frame() %>% 
  mutate(type="base")

M2 <- coef_M2$cafe[,1,] %>% 
  data.frame() %>% 
  mutate(type="M2")
```

図示してみると、結果は類似している。しかし、切片と傾きの相関は`b14.1`では`r round(cor(base$Intercept, base$afternoon),2)`、`b14M2`では`r round(cor(M2$Intercept, M2$afternoon),2)`で、相関を仮定したモデルの方が高いことが分かる。

```{r, echo = FALSE}
bind_rows(base,M2) %>% 
  ggplot(aes(x = Intercept, y = afternoon))+
  geom_point(aes(color = type, shape = type))+
  scale_color_manual(values = c("navy","black"))+
  scale_shape_manual(values = c(19,1))+
  ylab("slope")+
  theme(aspect.ratio=1)
```
